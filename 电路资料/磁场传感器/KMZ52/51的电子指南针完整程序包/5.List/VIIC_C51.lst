C51 COMPILER V8.08   VIIC_C51                                                              05/28/2008 01:31:36 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE VIIC_C51
OBJECT MODULE PLACED IN .\4.Obj\VIIC_C51.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 3.Source\VIIC_C51.c BROWSE INCDIR(.\2.Inc) DEBUG OBJECTEXTEND PRINT(.\5.Lis
                    -t\VIIC_C51.lst) OBJECT(.\4.Obj\VIIC_C51.obj)

line level    source

   1          /********************************************************************
   2                                 VIIC_C51.C
   3            此程序是I2C操作平台（主方式的软件平台）的底层的C子程序,如发送数据
   4          及接收数据,应答位发送,并提供了几个直接面对器件的操作函数，它很方便的
   5          与用户程序连接并扩展.....  
   6            
   7              注意:函数是采用软件延时的方法产生SCL脉冲,固对高晶振频率要作 
   8          一定的修改....(本例是1us机器周期,即晶振频率要小于12MHZ)
   9          
  10          ********************************************************************/
  11                       
  12          #include <reg52.h>          /*头文件的包含*/
  13          #include <intrins.h>
  14          
  15          #define  _Nop()  _nop_()        /*定义空指令*/
  16          #include "Pindefine.h"
  17          /* 常,变量定义区 */
  18          bit ack;                 /*应答标志位*/
  19             
  20          
  21          
  22          
  23          
  24          
  25          /*******************************************************************
  26                               起动总线函数               
  27          函数原型: void  Start_I2c();  
  28          功能:       启动I2C总线,即发送I2C起始条件.
  29            
  30          ********************************************************************/
  31          void Start_I2c()
  32          {
  33   1        SDA=1;   /*发送起始条件的数据信号*/
  34   1        _Nop();
  35   1        SCL=1;
  36   1        _Nop();    /*起始条件建立时间大于4.7us,延时*/
  37   1        _Nop();
  38   1        _Nop();
  39   1        _Nop();
  40   1        _Nop();    
  41   1        SDA=0;   /*发送起始信号*/
  42   1        _Nop();    /* 起始条件锁定时间大于4μs*/
  43   1        _Nop();
  44   1        _Nop();
  45   1        _Nop();
  46   1        _Nop();       
  47   1        SCL=0;   /*钳住I2C总线，准备发送或接收数据 */
  48   1        _Nop();
  49   1        _Nop();
  50   1      }
  51          
  52          
  53          
  54          
C51 COMPILER V8.08   VIIC_C51                                                              05/28/2008 01:31:36 PAGE 2   

  55          /*******************************************************************
  56                                结束总线函数               
  57          函数原型: void  Stop_I2c();  
  58          功能:       结束I2C总线,即发送I2C结束条件.
  59            
  60          ********************************************************************/
  61          void Stop_I2c()
  62          {
  63   1        SDA=0;  /*发送结束条件的数据信号*/
  64   1        _Nop();   /*发送结束条件的时钟信号*/
  65   1        SCL=1;  /*结束条件建立时间大于4μs*/
  66   1        _Nop();
  67   1        _Nop();
  68   1        _Nop();
  69   1        _Nop();
  70   1        _Nop();
  71   1        SDA=1;  /*发送I2C总线结束信号*/
  72   1        _Nop();
  73   1        _Nop();
  74   1        _Nop();
  75   1        _Nop();
  76   1      }
  77          
  78          
  79          
  80          
  81          /*******************************************************************
  82                           字节数据传送函数               
  83          函数原型: void  SendByte(unsigned char c);
  84          功能:  将数据c发送出去,可以是地址,也可以是数据,发完后等待应答,并对
  85               此状态位进行操作.(不应答或非应答都使ack=0 假)     
  86               发送数据正常，ack=1; ack=0表示被控器无应答或损坏。
  87          ********************************************************************/
  88          void  SendByte(unsigned char c)
  89          {
  90   1       unsigned char BitCnt;
  91   1       
  92   1       for(BitCnt=0;BitCnt<8;BitCnt++)  /*要传送的数据长度为8位*/
  93   1          {
  94   2           if((c<<BitCnt)&0x80)SDA=1;   /*判断发送位*/
  95   2             else  SDA=0;                
  96   2           _Nop();
  97   2           SCL=1;               /*置时钟线为高，通知被控器开始接收数据位*/
  98   2            _Nop(); 
  99   2            _Nop();               /*保证时钟高电平周期大于4μs*/
 100   2            _Nop();
 101   2            _Nop();
 102   2            _Nop();         
 103   2           SCL=0; 
 104   2          }
 105   1          
 106   1          _Nop();
 107   1          _Nop();
 108   1          SDA=1;               /*8位发送完后释放数据线，准备接收应答位*/
 109   1          _Nop();
 110   1          _Nop();   
 111   1          SCL=1;
 112   1          _Nop();
 113   1          _Nop();
 114   1          _Nop();
 115   1          if(SDA==1)ack=0;     
 116   1             else ack=1;        /*判断是否接收到应答信号*/
C51 COMPILER V8.08   VIIC_C51                                                              05/28/2008 01:31:36 PAGE 3   

 117   1          SCL=0;
 118   1          _Nop();
 119   1          _Nop();
 120   1      }
 121          
 122          
 123          
 124          
 125          
 126          
 127          /*******************************************************************
 128                           字节数据传送函数               
 129          函数原型: unsigned char  RcvByte();
 130          功能:  用来接收从器件传来的数据,并判断总线错误(不发应答信号)，
 131               发完后请用应答函数。  
 132          ********************************************************************/   
 133          unsigned char  RcvByte()
 134          {
 135   1        unsigned char retc;
 136   1        unsigned char BitCnt;
 137   1        
 138   1        retc=0; 
 139   1        SDA=1;             /*置数据线为输入方式*/
 140   1        for(BitCnt=0;BitCnt<8;BitCnt++)
 141   1            {
 142   2              _Nop();           
 143   2              SCL=0;       /*置时钟线为低，准备接收数据位*/
 144   2              _Nop();
 145   2              _Nop();         /*时钟低电平周期大于4.7μs*/
 146   2              _Nop();
 147   2              _Nop();
 148   2              _Nop();
 149   2              SCL=1;       /*置时钟线为高使数据线上数据有效*/
 150   2              _Nop();
 151   2              _Nop();
 152   2              retc=retc<<1;
 153   2              if(SDA==1)retc=retc+1; /*读数据位,接收的数据位放入retc中 */
 154   2              _Nop();
 155   2              _Nop(); 
 156   2            }
 157   1        SCL=0;    
 158   1        _Nop();
 159   1        _Nop();
 160   1        return(retc);
 161   1      }
 162          
 163          
 164          
 165          
 166          /********************************************************************
 167                               应答子函数
 168          原型:  void Ack_I2c(bit a);
 169           
 170          功能:主控器进行应答信号,(可以是应答或非应答信号)
 171          ********************************************************************/
 172          void Ack_I2c(bit a)
 173          {
 174   1        
 175   1        if(a==0)SDA=0;     /*在此发出应答或非应答信号 */
 176   1              else SDA=1;
 177   1        _Nop();
 178   1        _Nop();
C51 COMPILER V8.08   VIIC_C51                                                              05/28/2008 01:31:36 PAGE 4   

 179   1        _Nop();      
 180   1        SCL=1;
 181   1          _Nop();
 182   1          _Nop();              /*时钟低电平周期大于4μs*/
 183   1          _Nop();
 184   1          _Nop();
 185   1          _Nop();  
 186   1       SCL=0;                /*清时钟线，钳住I2C总线以便继续接收*/
 187   1          _Nop();
 188   1          _Nop();    
 189   1      }
 190          
 191          
 192          
 193          
 194          
 195          
 196          /*******************************************************************
 197                              向无子地址器件发送字节数据函数               
 198          函数原型: bit  ISendByte(unsigned char sla,ucahr c);  
 199          功能:     从启动总线到发送地址，数据，结束总线的全过程,从器件地址sla.
 200                     如果返回1表示操作成功，否则操作有误。
 201          注意：    使用前必须已结束总线。
 202          ********************************************************************/
 203          bit ISendByte(unsigned char sla,unsigned char c)
 204          {
 205   1         Start_I2c();               /*启动总线*/
 206   1         SendByte(sla);            /*发送器件地址*/
 207   1           if(ack==0)return(0);
 208   1         SendByte(c);               /*发送数据*/
 209   1           if(ack==0)return(0);
 210   1        Stop_I2c();                 /*结束总线*/ 
 211   1        return(1);
 212   1      }
 213          
 214          
 215          
 216          
 217          /*******************************************************************
 218                              向有子地址器件发送多字节数据函数               
 219          函数原型: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);  
 220          功能:     从启动总线到发送地址，子地址,数据，结束总线的全过程,从器件
 221                    地址sla，子地址suba，发送内容是s指向的内容，发送no个字节。
 222                     如果返回1表示操作成功，否则操作有误。
 223          注意：    使用前必须已结束总线。
 224          ********************************************************************/
 225          bit ISendStr(unsigned char sla,unsigned char suba,unsigned char *s,unsigned char no)
 226          {
 227   1         unsigned char i;
 228   1      
 229   1         Start_I2c();               /*启动总线*/
 230   1         SendByte(sla);            /*发送器件地址*/
 231   1           if(ack==0)return(0);
 232   1         SendByte(suba);            /*发送器件子地址*/
 233   1           if(ack==0)return(0);
 234   1      
 235   1         for(i=0;i<no;i++)
 236   1          {   
 237   2           SendByte(*s);               /*发送数据*/
 238   2             if(ack==0)return(0);
 239   2           s++;
 240   2          } 
C51 COMPILER V8.08   VIIC_C51                                                              05/28/2008 01:31:36 PAGE 5   

 241   1       Stop_I2c();                 /*结束总线*/ 
 242   1        return(1);
 243   1      }
 244          
 245          
 246          
 247          
 248          
 249          
 250          /*******************************************************************
 251                              向无子地址器件读字节数据函数               
 252          函数原型: bit  IRcvByte(unsigned char sla,ucahr *c);  
 253          功能:     从启动总线到发送地址，读数据，结束总线的全过程,从器件地
 254                    址sla，返回值在c.
 255                     如果返回1表示操作成功，否则操作有误。
 256          注意：    使用前必须已结束总线。
 257          ********************************************************************/
 258          bit IRcvByte(unsigned char sla,unsigned char *c)
 259          {
 260   1         Start_I2c();                /*启动总线*/
 261   1         SendByte(sla+1);           /*发送器件地址*/
 262   1           if(ack==0)return(0);
 263   1         *c=RcvByte();               /*读取数据*/
 264   1           Ack_I2c(1);               /*发送非就答位*/
 265   1        Stop_I2c();                  /*结束总线*/ 
 266   1        return(1);
 267   1      }
 268          
 269          
 270          
 271          /*******************************************************************
 272                              向有子地址器件读取多字节数据函数               
 273          函数原型: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);  
 274          功能:     从启动总线到发送地址，子地址,读数据，结束总线的全过程,从器件
 275                    地址sla，子地址suba，读出的内容放入s指向的存储区，读no个字节。
 276                     如果返回1表示操作成功，否则操作有误。
 277          注意：    使用前必须已结束总线。
 278          ********************************************************************/
 279          bit IRcvStr(unsigned char sla,unsigned char suba,unsigned char *s,unsigned char no)
 280          {
 281   1         unsigned char i;
 282   1      
 283   1         Start_I2c();               /*启动总线*/
 284   1         SendByte(sla);            /*发送器件地址*/
 285   1           if(ack==0)return(0);
 286   1         SendByte(suba);            /*发送器件子地址*/
 287   1           if(ack==0)return(0);
 288   1      
 289   1         Start_I2c();
 290   1         SendByte(sla+1);
 291   1            if(ack==0)return(0);
 292   1      
 293   1         for(i=0;i<no-1;i++)
 294   1          {   
 295   2           *s=RcvByte();               /*发送数据*/
 296   2            Ack_I2c(0);                /*发送就答位*/  
 297   2           s++;
 298   2          } 
 299   1         *s=RcvByte();
 300   1          Ack_I2c(1);                 /*发送非应位*/
 301   1       Stop_I2c();                    /*结束总线*/ 
 302   1        return(1);
C51 COMPILER V8.08   VIIC_C51                                                              05/28/2008 01:31:36 PAGE 6   

 303   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    349    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
